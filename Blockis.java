/////////////////////////////////////////////////////////////////////
//
// Blockis by M.O.B. as Java ME MIDlet app for mobile phones.
// Copyright (C) 2007 by Mikael O. Bonnier, Lund, Sweden.
// License: GNU GPL v3 or later, http://www.gnu.org/licenses/gpl-3.0.txt
// Donations are welcome to PayPal mikael.bonnier@gmail.com.
// The source code is at <http://www.df.lth.se.orbin.se/~mikaelb/wap/>.
//
// Blockis is a game similar to Tetris(R). I didn't read any other tetris code before
// writing this. I only played and studied the behaviour of a hand held tetris-type game I
// bought in 1999 (238A, E-8238, All in One, 238 in One, Super King for 238 Game, ...it
// had many names on the package) and studied the information on rules in swedish
// wikipedia. In 238A Tetris is called Game I, Original Brick Game. My implementation
// doesn't behave exactly like the one in 238A. E.g. you cannot change speed, level or
// number of game (i.e. variations). Another difference is that rotation cannot move the
// block sideways or downwards in my current implementation. There is no sound.
//
// It was developed in J2ME (Java) using WTK-2.2 [patch 200511] and JDK 1.5.0_09 on
// Windows 2000. The jar-file was generated using the default obfuscator ProGuard 3.7
// using default settings. This file does also compile using WTK-2.5.2 and JDK 1.6.0_06 on
// Kubuntu Hardy Heron.
//
// Revision history:
// 2007-Jan-15:     v.0.0.2
// 2007-Jan-17:     v.0.0.3
// 2007-Jan-19:     v.0.1.0
// 2007-Jan-20:     v.0.1.1
// 2007-Feb-21:     v.0.1.2
// 2008-May-23      v.0.1.3
//
// Suggestions, improvements, and bug-reports
// are always welcome to:
//                  Mikael Bonnier
//                  Osten Undens gata 88
//                  SE-227 62  LUND
//                  SWEDEN
//
// Or use my electronic addresses:
//     Web: http://www.df.lth.se.orbin.se/~mikaelb/
//     E-mail/MSN: mikael.bonnier@gmail.com
//     ICQ # 114635318
//     Skype: mikael4u
//              _____
//             /   / \
// ***********/   /   \***********
//           /   /     \
// *********/   /       \*********
//         /   /   / \   \
// *******/   /   /   \   \*******
//       /   /   / \   \   \
// *****/   /   /***\   \   \*****
//     /   /__ /_____\   \   \
// ***/               \   \   \***
//   /_________________\   \   \
// **\                      \  /**
//    \______________________\/
//
// Mikael O. Bonnier
/////////////////////////////////////////////////////////////////////

// The documentation is, on my system, generated by:
// C:\Program\Java\jdk1.5.0_09\bin\javadoc 
//    -classpath C:/WTK22/lib/midpapi20.jar -d docs -private -author -version Blockis.java

import javax.microedition.midlet.MIDlet;
import javax.microedition.lcdui.*;
import javax.microedition.lcdui.game.*;
import java.util.Random;

/**
 * This MIDlet class runs a tetris-type game and tests BlockisGameCanvas.
 * Motivation of design: This should only be a simple class to control starting, pausing 
 * and stopping of the game.
 * @author Mikael O. Bonnier
 * @version 0.1.1
 * @see BlockisGameCanvas
 */
public class Blockis extends MIDlet implements CommandListener {
   private String _sHelpText = "A tetris-type game. Left & right moves"
      + " the block sideways, down moves downwards faster, game A & game B"
      + " rotates the block. Fire & up works as game B. Note that game A,"
      + " game B, & fire can be on different positions than you are used"
      + " to because GameCanvas is used. In order to move"
      + " the block sideways one step, you must press the key briefly.\n\n"
      + "Homepage: <http://www.df.lth.se.orbin.se/~mikaelb/>.";
   private final BlockisGameCanvas _tgc = new BlockisGameCanvas(this);
   private Command _cmdExit;
   private Command _cmdStart;
   private Command _cmdPause;
   private Command _cmdResume;
   private Command _cmdHelp;
   private Command _cmdAbout;
   private final static int START = 0, PAUSE = 1, RESUME = 2;
   private int _nCommandState;

   public Blockis() 
   {
      _cmdExit = new Command("EXIT", Command.EXIT, 0);
      _cmdStart = new Command("START", Command.SCREEN, 1);
      _cmdPause = new Command("PAUSE", Command.STOP, 1);
      _cmdResume = new Command("RESUME", Command.SCREEN, 1);
      _cmdHelp = new Command("HELP", Command.HELP, 2);
      _cmdAbout = new Command("ABOUT", Command.SCREEN, 3);
      _tgc.addCommand(_cmdExit);
      _tgc.addCommand(_cmdStart);
      _tgc.addCommand(_cmdHelp);
      _tgc.addCommand(_cmdAbout);
      _nCommandState = START;
      _tgc.setCommandListener(this);
   }

   public void startApp() 
   {
      Display.getDisplay(this).setCurrent(_tgc);
      if(_nCommandState == START)
         commandAction(_cmdStart, _tgc);
      else if(_nCommandState == PAUSE)
         commandAction(_cmdResume, _tgc);
   }

   public void pauseApp() 
   {
      if(_nCommandState == PAUSE) {
         _tgc.stop();      
      }
   }

   public void destroyApp(boolean unconditional) 
   {
      _tgc.stop(); // Maybe not necessary.
   }

   public void commandAction(Command c, Displayable s) 
   {
      if(c == _cmdExit) {
         _tgc.stop();
         notifyDestroyed();
      }
      else if(c == _cmdStart) {
         _tgc.removeCommand(_cmdStart);    
         _tgc.addCommand(_cmdPause);
         _nCommandState = PAUSE;
         _tgc.start();
      }
      else if(c == _cmdPause) {
         _tgc.stop();
         _tgc.removeCommand(_cmdPause);    
         _tgc.addCommand(_cmdResume);
         _nCommandState = RESUME;
      }
      else if(c == _cmdResume) {
         _tgc.removeCommand(_cmdResume);
         _tgc.addCommand(_cmdPause);
         _nCommandState = PAUSE;
         _tgc.resume();
      }
      else if(c == _cmdHelp) {
         Alert alrHelp = new Alert("Blockis by M.O.B./Help", _sHelpText, null, AlertType.INFO);
         alrHelp.setTimeout(Alert.FOREVER);
         Display.getDisplay(this).setCurrent(alrHelp, _tgc);
      }
      else if(c == _cmdAbout) {
         Runtime rt = Runtime.getRuntime();
         Display disp = Display.getDisplay(this);
         Alert alrAbout = new Alert("Blockis by M.O.B. v." + getAppProperty("MIDlet-Version"), 
            "This program \"Blockis by M.O.B.\" is Copyright Â© 2007 by Mikael O. Bonnier, Lund, Sweden"
            +" <mikael.bonnier@gmail.com>."
            + " All rights reserved.\n"
            + "Free mem: " + rt.freeMemory() + " B\n"
            + "Total mem: " + rt.totalMemory() + " B\n"
            + "Profiles: " + System.getProperty("microedition.profiles") + '\n'
            + "Config: " + System.getProperty("microedition.configuration") + '\n'
            + "Encoding: " + System.getProperty("microedition.encoding") + '\n'
            + "Locale: " + System.getProperty("microedition.locale") + '\n'
            + "Canvas width: " + _tgc.getWidth() + '\n'
            + "Canvas height: " + _tgc.getHeight() + '\n'
            + "Double buffer: " + _tgc.isDoubleBuffered() + '\n'
            + "Color display: " + disp.isColor() + '\n'
            + "Alpha levels: " + disp.numAlphaLevels() + '\n'
            + "Colors: " + disp.numColors(),
            null, AlertType.INFO);
         alrAbout.setTimeout(Alert.FOREVER);
         Display.getDisplay(this).setCurrent(alrAbout, _tgc);
      }
   }

   void gameOver() 
   {
      _tgc.removeCommand(_cmdPause);    
      _tgc.addCommand(_cmdStart);      
      _nCommandState = START;
   }   
}

/**
 * This class is a tetris-type game.
 * Motivation of design: It uses arrays instead of vectors of objects because arrays are faster.
 * @author Mikael O. Bonnier
 * @version 0.1.1
 */
class BlockisGameCanvas extends GameCanvas implements Runnable {
   private final int _nDelay = 100; // ms
   private final int INTERLEAVE = 8;
   private final static int[] _nMColors = {0x000000, 
      0xFF0000, 0x00FF00, 0x0000FF, 0x00FFFF, 0xFF00FF, 0xFFFF00};
   private final static int MATRIX_ROWS = 20, MATRIX_COLS = 10;
   byte[][] _nMatrix = new byte[MATRIX_ROWS][MATRIX_COLS];  
   byte[][] _nMatrixPrev = new byte[MATRIX_ROWS][MATRIX_COLS];
   private final byte[][] _nBI = {{0,0,0,0},
                                  {1,1,1,1}};
   private final byte[][] _nBT = {{1,1,1},
                                  {0,1,0}};
   private final byte[][] _nBO = {{1,1},
                                  {1,1}};
   private final byte[][] _nBL = {{1,1,1},
                                  {1,0,0}};
   private final byte[][] _nBJ = {{1,1,1},
                                  {0,0,1}};
   private final byte[][] _nBS = {{0,1,1},
                                  {1,1,0}};
   private final byte[][] _nBZ = {{1,1,0},
                                  {0,1,1}};
   final byte[][][] _blocks = {_nBI, _nBT, _nBO, _nBL, _nBJ, _nBS, _nBZ};
   final BlockCollidesBlitter _bcb = new BlockCollidesBlitter(this);
   final ResetBlockBlitter _rbb = new ResetBlockBlitter(this);
   final SetBlockBlitter _sbb = new SetBlockBlitter(this);
   private boolean _bRunning;
   private final Blockis _mobt;
   private final static Random _rand = new Random();
   private int _iBlockNext, _iBlock, _iBlockPrev;
   private int _nRot, _nRotPrev;
   private int _nMRow, _nMCol, _nMRowPrev, _nMColPrev;
   private byte _iColorNext;
   byte _iColor;
   private boolean _bNewBlock;
   private final int _nScaleX, _nScaleY;
   private final int _nLevel = 0;
   private int _nScore, _nHiScore = 0;
  
   BlockisGameCanvas(Blockis mobt) 
   {
      super(true);
      _mobt = mobt;
      final int _ch = getHeight();
      _nScaleX = _nScaleY = _ch/MATRIX_ROWS;
      clearGraphics();
   }
  
   /**
    * This method clears the graphics.
    */
   void clearGraphics() 
   {
      // Clear the Graphics.
      final int _cw = getWidth();
      final int _ch = getHeight();
      Graphics g = getGraphics();
      g.setColor(_nMColors[0]);
      g.fillRect(0, 0, _cw, _ch);
      g.setColor(_nMColors[2]);
      g.drawRect(0, 0, MATRIX_COLS*_nScaleX+1, MATRIX_ROWS*_nScaleY+1);
      g.setGrayScale(0xFF);
      g.drawString(String.valueOf(_nScore), getWidth(), MATRIX_ROWS*_nScaleY, 
         Graphics.BASELINE | Graphics.RIGHT);
      g.drawString(String.valueOf(_nHiScore), getWidth(), (MATRIX_ROWS-8)*_nScaleY, 
         Graphics.BASELINE | Graphics.RIGHT);
   }

   /**
    * This method starts the game.
    */
   void start() 
   {
      _nScore = 0;
      clearGraphics();
      // Reset the matrix.
      for(int r = 0; r < MATRIX_ROWS; ++r)
         for(int c = 0; c < MATRIX_COLS; ++c)
            _nMatrix[r][c] = 0;
      _bNewBlock = true; 
      _iBlockNext = (_rand.nextInt() & Integer.MAX_VALUE)%_blocks.length;
      _iColorNext = (byte)((_rand.nextInt() 
         & Integer.MAX_VALUE)%(_nMColors.length - 1) + 1);
      _bRunning = true;
      Thread t = new Thread(this);
      t.start();
   }

   /**
    * This resumes animation after a pause.
    */
   void resume()
   {
      _bRunning = true;
      Thread t = new Thread(this);
      t.start();
   }
  
   /**
    * This is called to stop the animation when pausing, destroying or game over.
    */
   void stop() 
   {
      _bRunning = false;
   }

   /**
    * This method contains the main animation loop. It checks for key presses and moves and rotates the 
    * block accordingly.
    */
   public void run() 
   {
      boolean released = true;
      int loopCount = 1;

      while(_bRunning) {
         int ks = Math.abs(getKeyStates());

         if(released && ((ks & GAME_B_PRESSED) != 0 
            || (ks & FIRE_PRESSED) != 0 || (ks & UP_PRESSED) != 0)) {
               _nRot = _nRot >= 3 ? 0 : _nRot + 1;
               released = false;
         }
         else if(released && (ks & GAME_A_PRESSED) != 0) {
               _nRot = _nRot <= 0 ? 3 : _nRot - 1;
               released = false;
         }
         if(!released && (ks & GAME_B_PRESSED) == 0 && (ks & FIRE_PRESSED) == 0 
            && (ks & UP_PRESSED) == 0 && (ks & GAME_A_PRESSED) == 0)
            released = true;
         if((ks & RIGHT_PRESSED) != 0)
            ++_nMCol;
         else if((ks & LEFT_PRESSED) != 0)
            --_nMCol;
         
         if(_bNewBlock) {
            _nMRow = _nMRowPrev = 0;
            _nMCol = _nMColPrev = 3;
            _iBlock = _iBlockNext;
            if(_iBlock == 0) 
               _nMRow = _nMRowPrev = -1;
            _iBlockNext = (_rand.nextInt() & Integer.MAX_VALUE)%_blocks.length;
            _iColor = _iColorNext;
            _iColorNext = (byte)((_rand.nextInt() 
               & Integer.MAX_VALUE)%(_nMColors.length - 1) + 1);
            _nRot = 0;
         }
         drawBlock();

         render();
         flushGraphics();
         sleep(_nDelay);
         if((ks & DOWN_PRESSED) != 0 || loopCount % INTERLEAVE == 0)
            ++_nMRow; 
         ++loopCount; // loopCount will wrap around at Integer.MAX_VALUE.
      }
   }

   /**
    * This method calls other methods which draws the falling block on the matrix. If there 
    * would be a collision with walls or the ground it tries to prevent it by prohibiting 
    * rotation and motion or restricting motion. This method also detects Game Over.
    */
   void drawBlock() 
   {
      if(!_bNewBlock)
         resetBlock();
      if(blockCollides()) {
         if(!_bNewBlock) {
            if(_nRot != _nRotPrev) {
               _nRot = _nRotPrev;
               if(!blockCollides()) {
                  moveOn();
                  return;
               }
            }
            if(_nMRow != _nMRowPrev && _nMCol == _nMColPrev) {
               hitGround();
            } 
            else if(_nMCol != _nMColPrev && _nMRow != _nMRowPrev) {
               _nMCol = _nMColPrev;
               if(blockCollides()) {
                  hitGround();                  
               }
               else {
                  moveOn();
               }
            }
            else {
               _nMCol = _nMColPrev;
               moveOn();
            } 
         }         
         else {
            Graphics g = getGraphics();
            g.setGrayScale(0x00);         
            g.drawString(String.valueOf(_nHiScore), getWidth(), (MATRIX_ROWS-8)*_nScaleY, 
               Graphics.BASELINE | Graphics.RIGHT);
            _nHiScore = Math.max(_nHiScore, _nScore); 
            g.setGrayScale(0xFF);
            g.drawString(String.valueOf(_nHiScore), getWidth(), (MATRIX_ROWS-8)*_nScaleY, 
               Graphics.BASELINE | Graphics.RIGHT);
            g.drawString("GAME OVER", (MATRIX_COLS+1)*_nScaleX, 0, Graphics.TOP | Graphics.LEFT);
            stop();
            _mobt.gameOver();
         }
      } 
      else {
         moveOn();
      }
   } 

   /**
    * This method is called when there is no collision or a collision that has been avoided. 
    * It allows the block to continue its fall.
    */
   void moveOn() 
   {
      _bNewBlock = false;
      setBlock();
      _iBlockPrev = _iBlock;
      _nRotPrev = _nRot;
      _nMRowPrev = _nMRow; _nMColPrev = _nMCol;
   }

   /**
    * This method is called when a block hits the ground and it checks for full rows
    * and compacts according to the rules of standard tetris. Points calculation
    * is done here.
    */
   void hitGround() 
   {
      _bNewBlock = true;
      _nMRow = _nMRowPrev; _nMCol = _nMColPrev;
      setBlock();

      boolean fullLines[] = new boolean[MATRIX_ROWS];
      boolean existsFull, isFull;
      existsFull = false;
      int noOfLines = 0;
      for(int r = MATRIX_ROWS - 1; r >= 0; --r) {
         isFull = true;
         for(int c = 0; c < MATRIX_COLS; ++c) 
            if(_nMatrix[r][c] == 0) {
               isFull = false;
               break;
            }
         if(fullLines[r] = isFull) {
            existsFull = true;
            ++noOfLines;
            for(int c = 0; c < MATRIX_COLS; ++c) 
               _nMatrix[r][c] = 0;
         }
      }

      final int scores[] = {40, 100, 300, 1200};
      if(existsFull) {
         Graphics g = getGraphics();
         g.setGrayScale(0x00);         
         g.drawString(String.valueOf(_nScore), getWidth(), MATRIX_ROWS*_nScaleY, 
            Graphics.BASELINE | Graphics.RIGHT);
         _nScore += (_nLevel+1)*scores[noOfLines-1]; 
         g.setGrayScale(0xFF);
         g.drawString(String.valueOf(_nScore), getWidth(), MATRIX_ROWS*_nScaleY, 
            Graphics.BASELINE | Graphics.RIGHT);

         render();         
         flushGraphics();
         sleep(_nDelay);
         for(int r = MATRIX_ROWS - 1; r >= 0; --r)
            while(fullLines[r]) {
               for(int rMove = r; rMove >= 1; --rMove) {
                  fullLines[rMove] = fullLines[rMove-1];
                  for(int c = 0; c < MATRIX_COLS; ++c) 
                     _nMatrix[rMove][c] = _nMatrix[rMove-1][c];
               }
               fullLines[0] = false;
               for(int c = 0; c < MATRIX_COLS; ++c) 
                  _nMatrix[0][c] = 0;              
               render();
               flushGraphics();
               sleep(INTERLEAVE*_nDelay);
            }
      }                    
   }

   /**
    * This method checks if a block will collide with the walls or the ground.
    * Notice that exception is used to detect collisions with the walls of the container.
    * Motivation of design: It's faster to use the built in array index check than writing your own redundant.
    * @return It returns true if collision, false otherwise.
    */
   boolean blockCollides()
   {
      try {
         _bcb.blit(_iBlock, _nRot, _nMRow, _nMCol);
      } catch(ArrayIndexOutOfBoundsException ae) {
         return true;
      }
      return false;
   }

   /**
    * This method wipes out the previously drawn block from the matrix.
    */
   void resetBlock() 
   {
      _rbb.blit(_iBlockPrev, _nRotPrev, _nMRowPrev, _nMColPrev);
   }

   /**
    * This method draws the current block on the matrix.
    */
   void setBlock()
   {
      _sbb.blit(_iBlock, _nRot, _nMRow, _nMCol);
   }
     
   /**
    * This method renders the tetris matrix on the Graphics with the current block and 
    * the next block.
    * Motivation of design: Graphics.fillRect is costly and should be avoided as much as possible.
    * Therefore the previous matrix is stored and only the changes are plotted.
    */
   void render() 
   {
      // Render the matrix.
      Graphics g = getGraphics();
      g.translate(2, 2);
      // g.setColor(_nMColors[0]);
      // g.fillRect(0, 0, MATRIX_COLS*_nScaleX - 1, MATRIX_ROWS*_nScaleY - 1);
      for(int r = 0; r < MATRIX_ROWS; ++r)
         for(int c = 0; c < MATRIX_COLS; ++c) 
            if(_nMatrix[r][c] != _nMatrixPrev[r][c]) {
               g.setColor(_nMColors[_nMatrix[r][c]]);
               g.fillRect(c*_nScaleX, r*_nScaleY, _nScaleX-1, _nScaleY-1);
               _nMatrixPrev[r][c] = _nMatrix[r][c];
            }
      g.translate(-2, -2);

      // Render the next block.
      g.translate((MATRIX_COLS+1)*_nScaleX + 2, 4*_nScaleY + 2); 
      g.setColor(_nMColors[0]);
      final int scaleNBX = (3*_nScaleX)/4, scaleNBY = (3*_nScaleY)/4;
      g.fillRect(0, 0, 4*scaleNBX, 2*scaleNBY);
      g.setColor(_nMColors[_iColorNext]);    
      // TODO: This might use Blitter.  
      final int BLOCK_ROWS = _blocks[_iBlockNext].length;
      final int BLOCK_COLS = _blocks[_iBlockNext][0].length;
      for(int r = 0; r < BLOCK_ROWS; ++r)
         for(int c = 0; c < BLOCK_COLS; ++c) 
            if(_blocks[_iBlockNext][r][c] != 0) 
               g.fillRect(c*scaleNBX, r*scaleNBY, scaleNBX-1, scaleNBY-1);
      g.translate(-((MATRIX_COLS+1)*_nScaleX + 2), -(4*_nScaleY + 2));
   }

   /**
    * This method sleeps. 
    * Motivation of design: Should save the battery compared to busy wait.
    * @param delay How long in ms render should sleep after its work is done.
    */
   void sleep(int delay) 
   {
      try { Thread.sleep(delay); }
      catch (InterruptedException ie) {}
   }
}


/**
 * This performs bit blitting.
 * Motivation of design: Reduces the amount of code that needs to be maintained.
 * This class replaced three almost identical methods in BlockisGameCanvas.
 * @author Mikael O. Bonnier
 * @version 0.1.1
 */
abstract class Blitter {
   protected final BlockisGameCanvas _tgc;
   private final static int _ROT0 = 0, _ROT90 = 1, _ROT180 = 2, _ROT270 = 3;

   Blitter(BlockisGameCanvas tgc)
   {
      _tgc = tgc;
   }

  /**
   * This method can blit the block on to the matrix, but exactly what it does depend on the
   * implementation of doCell() in the child class.
   * @exception ArrayIndexOutOfBoundsException If r and c is outside of the matrix or if collision.
   */   
   void blit(int block, int rot, int row, int col) throws ArrayIndexOutOfBoundsException {
      final int BLOCK_ROWS = _tgc._blocks[block].length, 
                BLOCK_COLS = _tgc._blocks[block][0].length;

      switch(rot) {
         case _ROT0:
            for(int r = 0; r < BLOCK_ROWS; ++r)
               for(int c = 0; c < BLOCK_COLS; ++c) 
                  if(_tgc._blocks[block][r][c] != 0)
                     doCell(row+r, col+c);
            break;
         case _ROT90:
            for(int r = 0; r < BLOCK_ROWS; ++r)
               for(int c = 0; c < BLOCK_COLS; ++c) 
                  if(_tgc._blocks[block][r][c] != 0)
                     doCell(row+c, col+(BLOCK_COLS-1-r));
            break;
         case _ROT180:
            for(int r = 0; r < BLOCK_ROWS; ++r)
               for(int c = 0; c < BLOCK_COLS; ++c)
                  if(_tgc._blocks[block][r][c] != 0)
                     doCell(row+(BLOCK_COLS-1-r), col+(BLOCK_COLS-1-c));
            break;
         case _ROT270:
            for(int r = 0; r < BLOCK_ROWS; ++r)
               for(int c = 0; c < BLOCK_COLS; ++c) 
                  if(_tgc._blocks[block][r][c] != 0)
                     doCell(row+(BLOCK_COLS-1-c), col+r);
            break;
      }
   }

  /**
   * This method can be used to do computations on or write to a cell in the matrix.
   * @param r The rownumber of the cell.
   * @param c The columnnumber of the cell.
   * @exception ArrayIndexOutOfBoundsException If r and c is outside of the matrix or if collision.
   */   
   protected abstract void doCell(int r, int c) throws ArrayIndexOutOfBoundsException;
}

/**
 * This class overrides doCell with block collision detection.
 * @author Mikael O. Bonnier
 * @version 0.1.1
 */
class BlockCollidesBlitter extends Blitter {
   BlockCollidesBlitter(BlockisGameCanvas tgc)
   {
      super(tgc);
   }

   protected void doCell(int r, int c) throws ArrayIndexOutOfBoundsException
   {
      if(_tgc._nMatrix[r][c] != 0)
         throw new ArrayIndexOutOfBoundsException();
   }
}

/**
 * This class overrides doCell with block reset code.
 * @author Mikael O. Bonnier
 * @version 0.1.1
 */
class ResetBlockBlitter extends Blitter {
   ResetBlockBlitter(BlockisGameCanvas tgc)
   {
      super(tgc);
   }

   protected void doCell(int r, int c) throws ArrayIndexOutOfBoundsException
   {
      _tgc._nMatrix[r][c] = 0;
   }
}

/**
 * This class overrides doCell with block set code.
 * @author Mikael O. Bonnier
 * @version 0.1.1
 */
class SetBlockBlitter extends Blitter {
   SetBlockBlitter(BlockisGameCanvas tgc)
   {
      super(tgc);
   }

   protected void doCell(int r, int c) throws ArrayIndexOutOfBoundsException
   {
      _tgc._nMatrix[r][c] = _tgc._iColor;
   }
}
